diff -uraN ../links-2.1pre9/Makefile.am ./Makefile.am
--- ../links-2.1pre9/Makefile.am	2002-06-08 15:11:51.000000000 +0200
+++ ./Makefile.am	2003-03-13 15:06:00.000000000 +0100
@@ -13,7 +13,7 @@
 else
 endif
 
-links_SOURCES=af_unix.c beos.c bfu.c bookmarks.c builtin.c cache.c charsets.c connect.c context.c cookies.c default.c dip.c dither.c dns.c drivers.c error.c file.c finger.c font_include.c framebuffer.c ftp.c gif.c html.c html_gr.c html_r.c html_tbl.c http.c https.c img.c imgcache.c ipret.c javascr.c javascript.c jpeg.c jsint.c kbd.c language.c links_icon.c listedit.c lru.c mailto.c main.c menu.c memory.c md5.c md5hl.c ns.c objreq.c os_dep.c pmshell.c png.c pomocny.c sched.c select.c session.c svgalib.c terminal.c tiff.c types.c url.c view.c view_gr.c win32.c x.c xbm.c links.h cfg.h os_dep.h os_depx.h setup.h codepage.h language.h codepage.inc entity.inc uni_7b.inc language.inc arrow.inc md5.h ns.h struct.h tree.h typy.h ipret.h javascript.h builtin.h builtin_keys.h bits.h
+links_SOURCES=af_unix.c beos.c bfu.c bookmarks.c builtin.c cache.c charsets.c connect.c context.c cookies.c default.c dip.c directfb.c directfb_cursors.h dither.c dns.c drivers.c error.c file.c finger.c font_include.c framebuffer.c ftp.c gif.c html.c html_gr.c html_r.c html_tbl.c http.c https.c img.c imgcache.c ipret.c javascr.c javascript.c jpeg.c jsint.c kbd.c language.c links_icon.c listedit.c lru.c mailto.c main.c menu.c memory.c md5.c md5hl.c ns.c objreq.c os_dep.c pmshell.c png.c pomocny.c sched.c select.c session.c svgalib.c terminal.c tiff.c types.c url.c view.c view_gr.c win32.c x.c xbm.c links.h cfg.h os_dep.h os_depx.h setup.h codepage.h language.h codepage.inc entity.inc uni_7b.inc language.inc arrow.inc md5.h ns.h struct.h tree.h typy.h ipret.h javascript.h builtin.h builtin_keys.h bits.h
 
 dist-hook:
 #remove the symlinka:
diff -uraN ../links-2.1pre9/acconfig.h ./acconfig.h
--- ../links-2.1pre9/acconfig.h	2002-05-02 22:40:11.000000000 +0200
+++ ./acconfig.h	2003-03-13 15:06:00.000000000 +0100
@@ -77,6 +77,9 @@
 #undef GRDRV_FB
 
 /* */
+#undef GRDRV_DIRECTFB
+
+/* */
 #undef GRDRV_PMSHELL
 
 /* */
diff -uraN ../links-2.1pre9/configure.in ./configure.in
--- ../links-2.1pre9/configure.in	2003-02-26 19:43:43.000000000 +0100
+++ ./configure.in	2003-03-13 15:13:22.000000000 +0100
@@ -336,6 +336,7 @@
 AC_ARG_WITH(svgalib, [  --without-svgalib       compile without svgalib graphics driver],[if test "$withval" = no; then disable_svgalib=yes; else disable_svgalib=no; fi])
 AC_ARG_WITH(x, [  --without-x             compile without X Window System graphics driver],[if test "$withval" = no; then disable_x=yes; else disable_x=no; fi])
 AC_ARG_WITH(fb, [  --without-fb            compile without Linux Framebuffer graphics driver],[if test "$withval" = no; then disable_fb=yes; else disable_fb=no; fi])
+AC_ARG_WITH(directfb, [  --without-directfb      compile without DirectFB graphics driver],[if test "$withval" = no; then disable_directfb=yes; else disable_directfb=no; fi])
 AC_ARG_WITH(pmshell, [  --without-pmshell       compile without PMShell graphics driver],[if test "$withval" = no; then disable_pmshell=yes; else disable_pmshell=no; fi])
 AC_ARG_WITH(atheos, [  --without-atheos        compile without Atheos graphics driver],[if test "$withval" = no; then disable_atheos=yes; else disable_atheos; fi])
 
@@ -374,6 +375,25 @@
 	fi
 fi
 
+if test "$disable_directfb" != yes ; then
+	AC_PATH_PROG(DIRECTFB_CONFIG, directfb-config, no)
+	if test "$DIRECTFB_CONFIG" != "no"; then
+	        AC_MSG_CHECKING(for DirectFB >= 0.9.17)
+        	directfb_version=`$DIRECTFB_CONFIG --version`
+		if expr $directfb_version \>= 0.9.17 >/dev/null; then
+			AC_MSG_RESULT(yes)
+			DIRECTFB_CFLAGS=`$DIRECTFB_CONFIG --cflags`
+			DIRECTFB_LIBS=`$DIRECTFB_CONFIG --libs`
+	           	AC_DEFINE(GRDRV_DIRECTFB)
+        	   	drivers="$drivers DIRECTFB"
+			CPPFLAGS="$CPPFLAGS $DIRECTFB_CFLAGS"
+			LIBS="$LIBS $DIRECTFB_LIBS"
+		else
+			AC_MSG_RESULT(no)
+		fi
+	fi
+fi
+
 	AC_PATH_X
 
 	if test "$have_x" = yes; then
diff -uraN ../links-2.1pre9/default.c ./default.c
--- ../links-2.1pre9/default.c	2003-02-11 22:55:00.000000000 +0100
+++ ./default.c	2003-03-13 15:06:00.000000000 +0100
@@ -79,6 +79,10 @@
 					goto found;
 				}
 			uu:
+#ifdef GRDRV_DIRECTFB
+                        if (!strncmp(argv[-1], "--dfb:", 6))
+                                goto found;
+#endif
 			fprintf(stderr, "Unknown option %s\n", argv[-1]);
 			return NULL;
 		} else if (!u) u = argv[-1];
diff -uraN ../links-2.1pre9/directfb.c ./directfb.c
--- ../links-2.1pre9/directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ ./directfb.c	2003-03-13 15:10:53.000000000 +0100
@@ -0,0 +1,847 @@
+/* directfb.c
+ * DirectFB graphics driver
+ * (c) 2002 Sven Neumann <sven@directfb.org>
+ *
+ * This file is a part of the Links program, released under GPL.
+ */
+
+/* TODO:
+ * - Store window size as driver params (?)
+ * - Fix wrong colors on big-endian systems (fixed?)
+ * - Make everything work correctly ;-)
+ *
+ * KNOWN PROBLEMS:
+ * - If mouse drags don't work for you, update DirectFB
+ *   (the upcoming 0.9.14 release fixes this).
+ */
+
+
+#include "cfg.h"
+
+#ifdef GRDRV_DIRECTFB
+
+#ifdef TEXT
+#undef TEXT
+#endif
+
+#include <netinet/in.h>  /* for htons */
+
+#include <directfb.h>
+
+#include "links.h"
+#include "directfb_cursors.h"
+
+
+#define FOCUSED_OPACITY    0xFF
+#define UNFOCUSED_OPACITY  0xC0
+
+#define DIRECTFB_HASH_TABLE_SIZE  23
+struct graphics_device **directfb_hash_table[DIRECTFB_HASH_TABLE_SIZE];
+
+typedef struct _DFBDeviceData DFBDeviceData;
+struct _DFBDeviceData
+{
+  DFBWindowID       id;
+  IDirectFBWindow  *window;
+  IDirectFBSurface *surface;
+  int               mapped;
+  DFBRegion         flip_region;
+  int               flip_pending;
+};
+
+
+extern struct graphics_driver directfb_driver;
+
+static IDirectFB             *dfb         = NULL;
+static IDirectFBDisplayLayer *layer       = NULL;
+static IDirectFBSurface      *arrow       = NULL;
+static IDirectFBEventBuffer  *events      = NULL;
+static DFBSurfacePixelFormat  pixelformat = DSPF_UNKNOWN;
+static int                    event_timer = 0;
+
+
+static inline void directfb_set_color  (IDirectFBSurface *surface, long color);
+static void directfb_register_flip     (DFBDeviceData *data,
+                                        int x, int y, int w, int h);
+static void directfb_flip_surface      (void *pointer);
+static void directfb_check_events      (void *pointer);
+static void directfb_translate_key     (DFBWindowEvent *event,
+                                        int *key, int *flag);
+static void directfb_add_to_table      (struct graphics_device *gd);
+static void directfb_remove_from_table (struct graphics_device *gd);
+static struct graphics_device * directfb_lookup_in_table (DFBWindowID  id);
+
+
+static unsigned char *
+directfb_fb_init_driver (unsigned char *param, unsigned char *display)
+{
+  DFBDisplayLayerConfig  config;
+  DFBResult              ret;
+
+  if (dfb)
+    return NULL;
+
+  DirectFBInit (&g_argc, (char ***) &g_argv);
+  ret = DirectFBCreate (&dfb);
+
+  if (ret)
+    {
+      char message[128];
+
+      snprintf (message, sizeof (message), "%s\n", DirectFBErrorString (ret));
+      return stracpy (message);
+    }
+
+  dfb->GetDisplayLayer (dfb, DLID_PRIMARY, &layer);
+
+  layer->GetConfiguration (layer, &config);
+
+  pixelformat = config.pixelformat;
+
+  directfb_driver.depth = (((DFB_BYTES_PER_PIXEL (pixelformat) & 0x7)) |
+                           ((DFB_BITS_PER_PIXEL  (pixelformat) & 0x1F) << 3));
+
+  /* endian test */
+  if (htons (0x1234) == 0x1234)
+    directfb_driver.depth |= 0x100;
+
+  directfb_driver.x = config.width;
+  directfb_driver.y = config.height;
+
+  memset (directfb_hash_table, 0, sizeof (directfb_hash_table));
+
+  if (dfb->CreateSurface (dfb, &arrow_desc, &arrow) != DFB_OK)
+    arrow = NULL;
+
+  return NULL;
+}
+
+static struct graphics_device *
+directfb_init_device (void)
+{
+  struct graphics_device *gd;
+  DFBDeviceData          *data;
+  IDirectFBWindow        *window;
+  DFBWindowDescription    desc;
+
+  if (!dfb || !layer)
+    return NULL;
+
+  desc.flags  = DWDESC_WIDTH | DWDESC_HEIGHT | DWDESC_POSX | DWDESC_POSY;
+  desc.width  = directfb_driver.x;
+  desc.height = directfb_driver.y;
+  desc.posx   = 0;
+  desc.posy   = 0;
+
+  if (layer->CreateWindow (layer, &desc, &window) != DFB_OK)
+    return NULL;
+
+  gd = mem_alloc (sizeof (struct graphics_device));
+
+  gd->size.x1 = 0;
+  gd->size.y1 = 0;
+  window->GetSize (window, &gd->size.x2, &gd->size.y2);
+
+  gd->clip = gd->size;
+
+  data = mem_alloc (sizeof (DFBDeviceData));
+  
+  data->window       = window;
+  data->mapped       = 0;
+  data->flip_pending = 0;
+
+  if (arrow)
+    window->SetCursorShape (window, arrow, arrow_hot_x, arrow_hot_y);
+
+  window->GetSurface (window, &data->surface);
+  window->GetID (window, &data->id);
+
+  gd->drv = &directfb_driver;
+  gd->driver_data = data;
+  gd->user_data   = NULL;
+
+  directfb_add_to_table (gd);
+
+  if (!events)
+    {
+      window->CreateEventBuffer (window, &events);
+      event_timer = install_timer (20, directfb_check_events, events);
+    }
+  else
+    {
+      window->AttachEventBuffer (window, events);
+    }
+
+  return gd;
+}
+
+static void
+directfb_shutdown_device (struct graphics_device *gd)
+{
+  DFBDeviceData *data;
+
+  if (!gd)
+    return;
+
+  data = gd->driver_data;
+
+  unregister_bottom_half (directfb_flip_surface, data);
+  directfb_remove_from_table (gd);
+
+  data->surface->Release (data->surface);
+  data->window->Release (data->window);
+
+  mem_free (data);
+  mem_free (gd);
+}
+
+static void
+directfb_shutdown_driver (void)
+{
+  int i;
+
+  if (!dfb)
+    return;
+
+  if (events)
+    {
+      kill_timer (event_timer);
+      events->Release (events);
+      events = NULL;
+    }
+
+  if (arrow)
+    arrow->Release (arrow);
+
+  layer->Release (layer);
+  dfb->Release (dfb);
+
+  for (i = 0; i < DIRECTFB_HASH_TABLE_SIZE; i++)
+    if (directfb_hash_table[i])
+      mem_free (directfb_hash_table[i]);
+
+  dfb = NULL;
+}
+
+static unsigned char *
+directfb_get_driver_param (void)
+{
+  return NULL;
+}
+
+static int
+directfb_get_empty_bitmap (struct bitmap *bmp)
+{
+  IDirectFBSurface      *surface;
+  DFBSurfaceDescription  desc;
+
+  bmp->data = bmp->flags = NULL;
+
+  desc.flags = DSDESC_WIDTH | DSDESC_HEIGHT;
+  desc.width  = bmp->x;
+  desc.height = bmp->y;
+
+  if (dfb->CreateSurface (dfb, &desc, &surface) != DFB_OK)
+    return 0;
+
+  surface->Lock (surface, DSLF_READ | DSLF_WRITE, &bmp->data, &bmp->skip);
+
+  bmp->flags = surface;
+
+  return 0;
+}
+
+static int
+directfb_get_filled_bitmap (struct bitmap *bmp, long color)
+{
+  IDirectFBSurface      *surface;
+  DFBSurfaceDescription  desc;
+
+  bmp->data = bmp->flags = NULL;
+
+  desc.flags = DSDESC_WIDTH | DSDESC_HEIGHT;
+  desc.width  = bmp->x;
+  desc.height = bmp->y;
+
+  if (dfb->CreateSurface (dfb, &desc, &surface) != DFB_OK)
+    return 0;
+
+  directfb_set_color (surface, color);
+  surface->FillRectangle (surface, 0, 0, bmp->x, bmp->y);
+  surface->Lock (surface, DSLF_READ | DSLF_WRITE, &bmp->data, &bmp->skip);
+
+  bmp->flags = surface;
+
+  return 0;
+}
+
+static void
+directfb_register_bitmap (struct bitmap *bmp)
+{
+  IDirectFBSurface *surface = bmp->flags;
+
+  surface->Unlock (surface);
+  bmp->data = NULL;
+}
+
+static void *
+directfb_prepare_strip (struct bitmap *bmp, int top, int lines)
+{
+  IDirectFBSurface *surface = bmp->flags;
+
+  surface->Lock (surface, DSLF_READ | DSLF_WRITE, &bmp->data, &bmp->skip);
+
+  return ((unsigned char *) bmp->data + top * bmp->skip);
+}
+
+static void
+directfb_commit_strip (struct bitmap *bmp, int top, int lines)
+{
+  IDirectFBSurface *surface = bmp->flags;
+
+  surface->Unlock (surface);
+  bmp->data = NULL;
+}
+
+static void
+directfb_unregister_bitmap (struct bitmap *bmp)
+{
+  IDirectFBSurface *surface = bmp->flags;
+
+  surface->Release (surface);
+}
+
+static void
+directfb_draw_bitmap (struct graphics_device *gd, struct bitmap *bmp,
+                      int x, int y)
+{
+  DFBDeviceData    *data = gd->driver_data;
+  IDirectFBSurface *src  = bmp->flags;
+
+  data->surface->Blit (data->surface, src, NULL, x, y);
+
+  directfb_register_flip (data, x, y, bmp->x, bmp->y);
+}
+
+static void
+directfb_draw_bitmaps (struct graphics_device *gd, struct bitmap **bmps,
+                       int n, int x, int y)
+{
+  DFBDeviceData *data = gd->driver_data;
+  struct bitmap *bmp  = *bmps;
+  int x1 = x;
+  int h  = 0;
+
+  if (n < 1)
+    return;
+
+  do
+    {
+      IDirectFBSurface *src = bmp->flags;
+      
+      data->surface->Blit (data->surface, src, NULL, x, y);
+
+      if (h < bmp->y)
+        h = bmp->y;
+
+      x += bmp->x;
+      bmp++;
+    }
+  while (--n);
+
+  directfb_register_flip (data, x1, y, x - x1, h);
+}
+
+static long
+directfb_get_color (int rgb)
+{
+  return rgb;
+}
+
+
+static void
+directfb_fill_area (struct graphics_device *gd,
+                    int x1, int y1, int x2, int y2, long color)
+{
+  DFBDeviceData *data = gd->driver_data;
+  int w = x2 - x1;
+  int h = y2 - y1;
+
+  directfb_set_color (data->surface, color);
+  data->surface->FillRectangle (data->surface, x1, y1, w, h);
+
+  directfb_register_flip (data, x1, y1, w, h);
+}
+
+static void
+directfb_draw_hline (struct graphics_device *gd,
+                     int left, int y, int right, long color)
+{
+  DFBDeviceData *data = gd->driver_data;
+
+  right--;
+
+  directfb_set_color (data->surface, color);
+  data->surface->DrawLine (data->surface, left, y, right, y);
+
+  directfb_register_flip (data, left, y, right - left, 1);
+}
+
+static void
+directfb_draw_vline (struct graphics_device *gd,
+                     int x, int top, int bottom, long color)
+{
+  DFBDeviceData *data = gd->driver_data;
+  
+  bottom--;
+
+  directfb_set_color (data->surface, color);
+  data->surface->DrawLine (data->surface, x, top, x, bottom);
+
+  directfb_register_flip (data, x, top, 1, bottom - top);
+}
+
+static void
+directfb_set_clip_area (struct graphics_device *gd, struct rect *r)
+{
+  DFBDeviceData *data   = gd->driver_data;
+  DFBRegion      region = { r->x1, r->y1, r->x2 - 1, r->y2 - 1};
+
+  gd->clip = *r;
+  
+  data->surface->SetClip (data->surface, &region);
+}
+
+static int
+directfb_hscroll (struct graphics_device *gd, struct rect_set **set, int sc)
+{
+  DFBDeviceData *data = gd->driver_data;
+  DFBRectangle   rect;
+
+  *set = NULL;
+  if (!sc)
+    return 0;
+
+  rect.x = gd->clip.x1;
+  rect.y = gd->clip.y1;
+  rect.w = gd->clip.x2 - rect.x;
+  rect.h = gd->clip.y2 - rect.y;
+
+  data->surface->Blit (data->surface,
+                       data->surface, &rect, rect.x + sc, rect.y);
+
+  directfb_register_flip (data, rect.x, rect.y, rect.w, rect.h);
+
+  return 1;
+}
+
+static int
+directfb_vscroll (struct graphics_device *gd, struct rect_set **set, int sc)
+{
+  DFBDeviceData *data = gd->driver_data;
+  DFBRectangle   rect;
+
+  *set = NULL;
+  if (!sc)
+    return 0;
+
+  rect.x = gd->clip.x1;
+  rect.y = gd->clip.y1;
+  rect.w = gd->clip.x2 - rect.x;
+  rect.h = gd->clip.y2 - rect.y;
+
+  data->surface->Blit (data->surface,
+                       data->surface, &rect, rect.x, rect.y + sc);
+
+  directfb_register_flip (data, rect.x, rect.y, rect.w, rect.h);
+
+  return 1;
+}
+
+struct graphics_driver directfb_driver = 
+{
+  "DirectFB",
+  directfb_fb_init_driver,
+  directfb_init_device,
+  directfb_shutdown_device,
+  directfb_shutdown_driver,
+  directfb_get_driver_param,
+  directfb_get_empty_bitmap,
+  directfb_get_filled_bitmap,
+  directfb_register_bitmap,
+  directfb_prepare_strip,
+  directfb_commit_strip,
+  directfb_unregister_bitmap,
+  directfb_draw_bitmap,
+  directfb_draw_bitmaps,
+  directfb_get_color,
+  directfb_fill_area,
+  directfb_draw_hline,
+  directfb_draw_vline,
+  directfb_hscroll,
+  directfb_vscroll,
+  directfb_set_clip_area,
+  dummy_block,
+  dummy_unblock,
+  NULL,	 /*  set_title  */
+  0,	 /*  depth      */
+  0, 0,	 /*  size       */
+  0,     /*  flags      */
+  0      /*  codepage   */
+};
+
+
+static inline void directfb_set_color (IDirectFBSurface *surface, long color)
+{
+  surface->SetColor (surface,
+                     (color & 0xFF0000) >> 16,
+                     (color & 0xFF00)   >> 8,
+                     (color & 0xFF),
+                     0xFF);
+}
+
+static void directfb_register_flip (DFBDeviceData *data,
+                                    int x, int y, int w, int h)
+{
+  if (x < 0 || y < 0 || w < 1 || h < 1)
+    return;
+
+  w = x + w - 1;
+  h = y + h - 1;
+
+  if (data->flip_pending)
+    {
+      if (data->flip_region.x1 > x)  data->flip_region.x1 = x;
+      if (data->flip_region.y1 > y)  data->flip_region.y1 = y;
+      if (data->flip_region.x2 < w)  data->flip_region.x2 = w;
+      if (data->flip_region.y2 < h)  data->flip_region.y2 = h;
+    }
+  else
+    {
+      data->flip_region.x1 = x;
+      data->flip_region.y1 = y;
+      data->flip_region.x2 = w;
+      data->flip_region.y2 = h;
+ 
+      data->flip_pending = 1;
+
+      register_bottom_half (directfb_flip_surface, data);
+    }
+}
+
+static void
+directfb_flip_surface (void *pointer)
+{
+  DFBDeviceData *data = pointer;
+
+  if (!data->flip_pending)
+    return;
+
+  data->surface->Flip (data->surface, &data->flip_region, 0);
+
+  data->flip_pending = 0;
+}
+
+static void
+directfb_check_events (void *pointer)
+{
+  struct graphics_device *gd   = NULL;
+  DFBDeviceData          *data = NULL;
+  DFBWindowEvent          event;
+  DFBWindowEvent          next;
+
+  if (!events)
+    return;
+
+  while (events->GetEvent (events, DFB_EVENT (&event)) == DFB_OK)
+    {
+      switch (event.type)
+        {
+        case DWET_GOTFOCUS:
+        case DWET_LOSTFOCUS:
+        case DWET_POSITION_SIZE:
+        case DWET_SIZE:
+        case DWET_KEYDOWN:
+        case DWET_BUTTONDOWN:
+        case DWET_BUTTONUP:
+        case DWET_WHEEL:
+        case DWET_MOTION:
+          break;
+        default:
+          continue;
+        }
+
+      if (!data || data->id != event.window_id)
+        {
+          gd = directfb_lookup_in_table (event.window_id);
+          if (!gd)
+            continue;
+        }
+
+      data = gd->driver_data;
+
+      switch (event.type)
+        {
+        case DWET_GOTFOCUS:
+          data->window->SetOpacity (data->window, FOCUSED_OPACITY);
+          break;
+
+        case DWET_LOSTFOCUS:
+          data->window->SetOpacity (data->window, UNFOCUSED_OPACITY);
+          break;
+
+        case DWET_POSITION_SIZE:
+          if (!data->mapped)
+            {
+              struct rect r = { 0, 0, event.w, event.h };
+              
+              gd->redraw_handler (gd, &r);
+              data->window->SetOpacity (data->window, FOCUSED_OPACITY);
+              data->mapped = 1;
+            }
+          else
+          /* fallthru */
+        case DWET_SIZE:
+          while ((events->PeekEvent (events, DFB_EVENT (&next)) == DFB_OK)   &&
+                 (next.type == DWET_SIZE || next.type == DWET_POSITION_SIZE) &&
+                 (next.window_id == data->id))
+            events->GetEvent (events, DFB_EVENT (&event));
+
+          gd->size.x2 = event.w;
+          gd->size.y2 = event.h;
+          gd->resize_handler (gd);
+          break;
+
+        case DWET_KEYDOWN:
+          {
+            int key, flag;
+
+            directfb_translate_key (&event, &key, &flag);
+            if (key)
+              gd->keyboard_handler (gd, key, flag);
+          }
+          break;
+
+        case DWET_BUTTONDOWN:
+        case DWET_BUTTONUP:
+          {
+            int flags;
+
+            if (event.type == DWET_BUTTONUP)
+              {
+                flags = B_UP;
+                data->window->UngrabPointer (data->window);
+              }
+            else
+              {
+                flags = B_DOWN;
+                data->window->GrabPointer (data->window);
+              }
+
+            switch (event.button)
+              {
+              case DIBI_LEFT:
+                flags |= B_LEFT;
+                break;
+              case DIBI_RIGHT:
+                flags |= B_RIGHT;
+                break;
+              case DIBI_MIDDLE:
+                flags |= B_MIDDLE;
+                break;
+              default:
+                continue;
+              }
+
+            gd->mouse_handler (gd, event.x, event.y, flags);
+          }
+          break;
+
+        case DWET_WHEEL:
+          gd->mouse_handler (gd, event.x, event.y,
+                             B_MOVE |
+                             (event.step > 0 ? B_WHEELUP : B_WHEELDOWN));
+
+        case DWET_MOTION:
+          {
+            int flags;
+
+            while ((events->PeekEvent (events, DFB_EVENT (&next)) == DFB_OK) &&
+                   (next.type      == DWET_MOTION)                           &&
+                   (next.window_id == data->id))
+              events->GetEvent (events, DFB_EVENT (&event));
+
+            switch (event.buttons)
+              {
+              case DIBM_LEFT:
+                flags = B_DRAG | B_LEFT;
+                break;
+              case DIBM_RIGHT:
+                flags = B_DRAG | B_RIGHT;
+                break;
+              case DIBM_MIDDLE:
+                flags = B_DRAG | B_MIDDLE;
+                break;
+              default:
+                flags = B_MOVE;
+                break;
+              }
+
+            gd->mouse_handler (gd, event.x, event.y, flags);
+          }
+          break;
+
+        case DWET_CLOSE:
+          gd->keyboard_handler (gd, KBD_CLOSE, 0);
+          break;
+
+        default:
+          break;
+        }
+    }
+
+  event_timer = install_timer (20, directfb_check_events, events);
+}
+
+static void
+directfb_translate_key (DFBWindowEvent *event, int *key, int *flag)
+{
+  *key  = 0;
+  *flag = 0;
+
+  if (event->modifiers & DIMM_CONTROL && event->key_id == DIKI_C)
+    {
+      *key = KBD_CTRL_C;
+      return;
+    }
+
+  /* setting Shift seems to break things
+   *
+   *  if (event->modifiers & DIMM_SHIFT)
+   *     *flag |= KBD_SHIFT;
+   */
+  if (event->modifiers & DIMM_CONTROL)
+    *flag |= KBD_CTRL;
+  if (event->modifiers & DIMM_ALT)
+    *flag |= KBD_ALT;
+
+  switch (event->key_symbol)
+    {
+    case DIKS_ENTER:        *key = KBD_ENTER;     break;
+    case DIKS_BACKSPACE:    *key = KBD_BS;        break;
+    case DIKS_TAB:          *key = KBD_TAB;       break;
+    case DIKS_ESCAPE:       *key = KBD_ESC;       break;
+    case DIKS_CURSOR_UP:    *key = KBD_UP;        break;
+    case DIKS_CURSOR_DOWN:  *key = KBD_DOWN;      break;
+    case DIKS_CURSOR_LEFT:  *key = KBD_LEFT;      break;
+    case DIKS_CURSOR_RIGHT: *key = KBD_RIGHT;     break;
+    case DIKS_INSERT:       *key = KBD_INS;       break;
+    case DIKS_DELETE:       *key = KBD_DEL;       break;
+    case DIKS_HOME:         *key = KBD_HOME;      break;
+    case DIKS_END:          *key = KBD_END;       break;
+    case DIKS_PAGE_UP:      *key = KBD_PAGE_UP;   break;
+    case DIKS_PAGE_DOWN:    *key = KBD_PAGE_DOWN; break;
+    case DIKS_F1:           *key = KBD_F1;        break;
+    case DIKS_F2:           *key = KBD_F2;        break;
+    case DIKS_F3:           *key = KBD_F3;        break;
+    case DIKS_F4:           *key = KBD_F4;        break;
+    case DIKS_F5:           *key = KBD_F5;        break;
+    case DIKS_F6:           *key = KBD_F6;        break;
+    case DIKS_F7:           *key = KBD_F7;        break;
+    case DIKS_F8:           *key = KBD_F8;        break;
+    case DIKS_F9:           *key = KBD_F9;        break;
+    case DIKS_F10:          *key = KBD_F10;       break;
+    case DIKS_F11:          *key = KBD_F11;       break;
+    case DIKS_F12:          *key = KBD_F12;       break;
+
+    default:
+      if (DFB_KEY_TYPE (event->key_symbol) == DIKT_UNICODE)
+        *key = event->key_symbol;
+      break;
+    }
+}
+
+static void
+directfb_add_to_table (struct graphics_device *gd)
+{
+  DFBDeviceData           *data = gd->driver_data;
+  struct graphics_device **devices;
+  int i;
+
+  i = data->id % DIRECTFB_HASH_TABLE_SIZE;
+  
+  devices = directfb_hash_table[i];
+
+  if (devices)
+    {
+      int c = 0;
+
+      while (devices[c++])
+        ;
+
+      devices = mem_realloc (devices, (c + 1) * sizeof (void *));
+      devices[c-1] = gd;
+      devices[c]   = NULL;
+    }
+  else
+    {
+      devices = mem_alloc (2 * sizeof (void *));
+      devices[0] = gd;
+      devices[1] = NULL;
+    }
+
+  directfb_hash_table[i] = devices;
+}
+
+static void
+directfb_remove_from_table (struct graphics_device *gd)
+{
+  DFBDeviceData           *data = gd->driver_data;
+  struct graphics_device **devices;
+  int i, j, c;
+
+  i = data->id % DIRECTFB_HASH_TABLE_SIZE;
+
+  devices = directfb_hash_table[i];
+  if (!devices)
+    return;
+
+  for (j = 0, c = -1; devices[j]; j++)
+    if (devices[j] == gd)
+      c = j;
+
+  if (c < 0)
+    return;
+
+  memmove (devices + c, devices + c + 1, (j - c) * sizeof (void *));
+  devices = mem_realloc (devices, j * sizeof (void *));
+
+  directfb_hash_table[i] = devices;
+}
+
+static struct graphics_device *
+directfb_lookup_in_table (DFBWindowID id)
+{
+  struct graphics_device **devices;
+  int i;
+
+  i = id % DIRECTFB_HASH_TABLE_SIZE;
+
+  devices = directfb_hash_table[i];
+  if (!devices)
+    return NULL;
+
+  while (*devices)
+    {
+      DFBDeviceData *data = (*devices)->driver_data;
+
+      if (data->id == id)
+        return *devices;
+
+      devices++;
+    }
+
+  return NULL;
+}
+
+#endif /* GRDRV_DIRECTFB */
diff -uraN ../links-2.1pre9/directfb_cursors.h ./directfb_cursors.h
--- ../links-2.1pre9/directfb_cursors.h	1970-01-01 01:00:00.000000000 +0100
+++ ./directfb_cursors.h	2003-03-13 15:06:00.000000000 +0100
@@ -0,0 +1,80 @@
+/* DirectFB surface dump created by directfb-csource 0.9.14 */
+
+/* This arrow cursor surface is based on a cursor drawn by Ville Pätsi. */
+static unsigned char arrow_data[] = 
+  "\0\0\0\0\0\0\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0/\253\253\253\320\0\0\0N\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0H\306\306\306\363\200\200\200\320\0\0\0Y\0"
+  "\0\0\21\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\377\377\377\377\301"
+  "\301\301\372\223\223\223\347\0\0\0k\0\0\0\30\0\0\0\6\0\0\0\2\0\0\0\1"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0]\377\377\377\377\377\377\377\377\264\264\264\373\213\213\213"
+  "\352\0\0\0u\0\0\0\36\0\0\0\10\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\377\377\377\377\375\375"
+  "\375\377\356\356\356\377\254\254\254\374\206\206\206\354\0\0\0y\0\0\0"
+  "!\0\0\0\10\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0`\377\377\377\377\372\372\372\377\355\355\355\377"
+  "\343\343\343\377\247\247\247\374\203\203\203\354\0\0\0z\0\0\0\"\0\0\0"
+  "\11\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0`\377\377\377\377\365\365\365\377\351\351\351\377\341\341\341\377"
+  "\335\335\335\377\243\243\243\374\177\177\177\355\0\0\0{\0\0\0\"\0\0\0"
+  "\11\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\371"
+  "\371\371\377\360\360\360\377\346\346\346\377\337\337\337\377\333\333"
+  "\333\377\327\327\327\377\236\236\236\374{{{\355\0\0\0{\0\0\0\"\0\0\0"
+  "\11\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\365\365\365"
+  "\377\355\355\355\377\342\342\342\377\333\333\333\377\330\330\330\377"
+  "\325\325\325\377\317\317\317\377\227\227\227\374vvv\355\0\0\0{\0\0\0"
+  "\"\0\0\0\11\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\361\361\361"
+  "\377\350\350\350\377\335\335\335\377\326\326\326\377\324\324\324\377"
+  "\317\317\317\377\307\307\307\377\277\277\277\377\216\216\216\374qqq\352"
+  "\0\0\0r\0\0\0\33\0\0\0\11\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0`\353"
+  "\353\353\377\340\340\340\377\324\324\324\377\317\317\317\377\315\315"
+  "\315\377\307\307\307\377\274\274\274\377\257\257\257\377\212\212\212"
+  "\375ggg\357\\\\\\\313\0\0\0F\0\0\0\24\0\0\0\11\0\0\0\3\0\0\0\1\0\0\0"
+  "\0\0\0\0`\340\340\340\377\321\321\321\377\305\305\305\377\304\304\304"
+  "\377\307\307\307\377\302\302\302\377\242\242\242\376HHH\361\0\0\0\267"
+  "\0\0\0\224\0\0\0t\0\0\0?\0\0\0\"\0\0\0\22\0\0\0\7\0\0\0\2\0\0\0\0\0\0"
+  "\0]\321\321\321\377\277\277\277\377\207\207\207\374jjj\367\302\302\302"
+  "\377\301\301\301\377\263\263\263\377!!!\334\0\0\0\215\0\0\0d\0\0\0Q\0"
+  "\0\0>\0\0\0-\0\0\0\33\0\0\0\14\0\0\0\4\0\0\0\1\0\0\0E\230\230\230\363"
+  "kkk\353\0\0\0\243\0\0\0\254\200\200\200\370\304\304\304\377\271\271\271"
+  "\377ttt\371\0\0\0\233\0\0\0Y\0\0\0F\0\0\0<\0\0\0.\0\0\0\36\0\0\0\16\0"
+  "\0\0\4\0\0\0\1\0\0\0\7\0\0\0M\0\0\0]\0\0\0O\0\0\0f'''\305\304\304\304"
+  "\377\274\274\274\377\253\253\253\377\22\22\22\277\0\0\0e\0\0\0A\0\0\0"
+  "3\0\0\0%\0\0\0\27\0\0\0\13\0\0\0\4\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\24\0"
+  "\0\0)\0\0\0<\0\0\0\207\223\223\223\373\267\267\267\377\252\252\252\377"
+  "YYY\360\0\0\0\203\0\0\0@\0\0\0+\0\0\0\32\0\0\0\15\0\0\0\6\0\0\0\2\0\0"
+  "\0\0\0\0\0\0\0\0\0\2\0\0\0\11\0\0\0\27\0\0\0'\0\0\0N===\312\257\257\257"
+  "\377\242\242\242\377lll\370\0\0\0\221\0\0\0E\0\0\0)\0\0\0\26\0\0\0\11"
+  "\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\15\0\0\0\26\0"
+  "\0\0\33\0\0\0\\CCC\322ppp\366MMM\345\0\0\0\204\0\0\0I\0\0\0-\0\0\0\31"
+  "\0\0\0\12\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\5\0\0"
+  "\0\11\0\0\0\13\0\0\0\20\0\0\0E\0\0\0s\0\0\0w\0\0\0Z\0\0\0E\0\0\0""2\0"
+  "\0\0\35\0\0\0\14\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\1\0\0\0\2\0\0\0\3\0\0\0\4\0\0\0\12\0\0\0\36\0\0\0""4\0\0\0>\0\0\0"
+  "<\0\0\0""1\0\0\0\36\0\0\0\15\0\0\0\4\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\4\0\0\0\15\0\0\0\33\0"
+  "\0\0)\0\0\0.\0\0\0(\0\0\0\31\0\0\0\13\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\6\0\0"
+  "\0\15\0\0\0\26\0\0\0\33\0\0\0\30\0\0\0\17\0\0\0\7\0\0\0\2\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\1\0\0\0\4\0\0\0\10\0\0\0\13\0\0\0\12\0\0\0\6\0\0\0\3\0\0\0\1\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\2\0\0\0\3\0\0\0\3\0\0\0\1\0\0\0\1\0"
+  "\0\0\0\0\0\0\0\0\0\0\0";
+
+static DFBSurfaceDescription arrow_desc = {
+  flags                   : DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT |
+                            DSDESC_PREALLOCATED,
+  width                   : 18,
+  height                  : 25,
+  pixelformat             : DSPF_ARGB,
+  preallocated : {{  data : (void *) arrow_data,
+                    pitch : 72  }}
+};
+
+#define arrow_hot_x 1
+#define arrow_hot_y 1
diff -uraN ../links-2.1pre9/drivers.c ./drivers.c
--- ../links-2.1pre9/drivers.c	2002-10-12 21:46:24.000000000 +0200
+++ ./drivers.c	2003-03-13 15:06:01.000000000 +0100
@@ -22,6 +22,9 @@
 #ifdef GRDRV_FB
 extern struct graphics_driver fb_driver;
 #endif
+#ifdef GRDRV_DIRECTFB
+extern struct graphics_driver directfb_driver;
+#endif
 #ifdef GRDRV_PMSHELL
 extern struct graphics_driver pmshell_driver;
 #endif
@@ -39,6 +42,9 @@
 #ifdef GRDRV_X
 	&x_driver,
 #endif
+#ifdef GRDRV_DIRECTFB
+	&directfb_driver,
+#endif
 #ifdef GRDRV_SVGALIB
 	&svga_driver,
 #endif
diff -uraN ../links-2.1pre9/img.c ./img.c
--- ../links-2.1pre9/img.c	2003-02-20 14:01:12.000000000 +0100
+++ ./img.c	2003-03-13 15:06:01.000000000 +0100
@@ -514,11 +514,11 @@
 	       tmpbmp.data=(unsigned char *)cimg->bmp.data+cimg->bmp.skip*yoff;
 	       add1=cimg->bmp.skip*max_height;
 	}
-	tmpbmp.skip=cimg->bmp.skip;
 	add2=cimg->buffer_bytes_per_pixel*cimg->width*max_height;
 not_enough:
 	tmpbmp.y=height<max_height?height:max_height;
 	if (use_strip) tmpbmp.data=drv->prepare_strip(&(cimg->bmp),yoff,tmpbmp.y);
+	tmpbmp.skip=cimg->bmp.skip;
 	buffer_to_16(tmp, cimg, buffer, tmpbmp.y);
 	if (dregs){
 	       	dither_restart(tmp, &tmpbmp, dregs);
diff -uraN ../links-2.1pre9/os_dep.c ./os_dep.c
--- ../links-2.1pre9/os_dep.c	2003-01-10 23:13:49.000000000 +0100
+++ ./os_dep.c	2003-03-13 15:06:01.000000000 +0100
@@ -1182,7 +1182,7 @@
 		fn(ptr, p[1]);
 		write(p[1], "x", 1);
 		close(p[1]);
-		exit(0);
+		_exit(0);
 	}
 	if (f == -1) {
 		close(p[0]);
